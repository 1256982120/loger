
## JVM
- [Java 内存区域](#java-内存区域)
- [类的加载机制](#类的加载机制)
- [分代回收](#分代回收)
- [分代收集理论](#分代收集理论)
- [可达性分析算法](#可达性分析算法)
- [引用](#引用)
- [垃圾回收机制](#垃圾回收机制)
- [垃圾回收器](#垃圾回收器)
- [Full GC](#full-gc)
- [STW](#stw)
- [性能调优](#性能调优)
- [FullGC 内存泄露排查](#fullgc-内存泄露排查)
- [逃逸分析](#逃逸分析)
- [JVM 调优](#jvm-调优)

## Java 内存区域

- 虚拟机堆
- 虚拟机栈
- 方法区
- 本地方法栈
- 程序计数器

## 类的加载机制

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
- 双亲委派原则
  - 父类加载 不重复加载
- 破坏双亲委派模型
  - 第一次，在JDK1.2以前，双亲委派模型在 JDK1.2 引入，ClassLoder 在最初已经存在了，为了兼容已有代码，添加了findClass（）方法，如果父类加载失败会自动调用 findClass（）来完成加载
  - 第二次，由双亲委派模型缺陷导致，由于双亲委派越基础的类由越上层的加载器进行加载，如果有基础类型调回用户代码回无法解决而产生，出现线程上下文类加载器，会出现父类加载器请求子类加载器完成类加载的行为
  - 第三次，代码热替换、模块热部署，典型：OSGi 每一个程序模块都有一个自己的类加载器

## 分代回收

- 新生代/年轻代
- 老年代
- 永久代/元空间
  - 为什么要使用元空间取代永久代的实现 ？
    - 字符串存在永久代中，容易出现性能问题和内存溢出
    - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
    - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
    - 将 HotSpot 与 JRockit 合二为一
  - 元空间与永久代区别
    - 元空间并不在虚拟机中，而是使用本地内存。因此默认情况下，元空间的大小仅受本地内存限制
  - 元空间空间大小设置
    - -XX:MetaspaceSize：初始空间大小，达到该值会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值
    - -XX:MaxMetaspaceSize：最大空间，默认是没有限制的
- 晋升机制
  - 根据存活时间

## 分代收集理论

- 弱分代假说 : 绝大多数对象都是朝生熄灭的
- 强分代假说 : 熬过越多次垃圾收集过程的对象就越难以消亡
- 跨代引用假说 : 跨代引用相对于同代引用来说仅占极少数

## 可达性分析算法

- “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，如果某个对象到GC Roots间没有任何引用链相连接，则证明此对象是不可能再被使用的

## 引用

- 强引用 (StrongReference)
  - 强引用是使用最普遍的引用, 如果一个对象具有强引用，那垃圾回收器绝不会回收它; 当内存空间不足时，Java 虚拟机宁愿抛出OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
- 软引用 (SoftReference)
  - 如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
- 弱引用 (WeakReference)
  - 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
- 虚引用 (PhantomReference)
  - 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收

## 垃圾回收机制

- 标记请除
  - 适用场景
    - 对象存活较多情况
    - 老年代
  - 缺点
    - 内存空间碎片化
    - 由于空间碎片导致的提前 GC
    - 扫描了两次
      - 标记需清除或存货对象
      - 清除标记或未标记对象
- 标记复制
  - 适用场景
    - 存活对象少比较高效
    - 扫描了整个空间（标记存活对象并复制移动）
    - 年轻代
  - 缺点
    - 需要空闲空间
    - 老年代作为担保空间
    - 复制移动对象
- 标记整理
  - 适用场景
    - 对象存活较多情况
    - 老年代
  - 缺点
    - 移动存活对象并更新对象引用
    - Stop The World
- 引用计数
  - 没办法解决循环引用的问题

## 垃圾回收器

- CMS
  - 分代情况
    - 年轻代
      - Eden, Survivor1, Survivor2
      - Minor GC, 通过阈值晋升
    - 老年代
      - Major GC 等价于 Full GC
  - 缺点
    - 对 CPU 资源敏感
    - 无法处理浮动垃圾
    - 基于标记清除算法 大量空间碎片
- G1
  - 分区概念 弱化分代
  - 标记整理算法
    - 不会产生碎片空间，分配大对象不会提前Full GC
  - 允许用户设置收集的停顿时间
    - 使用参数-XX:MaxGCPauseMills，默认为200毫秒，优先处理回收价值收集最大的Region
  - 利用 CPU 多核条件，缩短 STW 时间
  - 原始快照算法（SATB）保证收集线程与用户线程互不干扰，避免标记结果出错
  - 收集步骤
    - 初始标记 : 标记 STW 从 GC Roots 开始直接可达的对象，借用 Minor GC 时同步完成
    - 并发标记 : 从 GC Roots 开始对堆对象进行可达性分析，找出要回收的对象，与用户程序并发执行，重新处理 SATB 记录下的并发时引用变动对象
    - 最终标记 : 处理并发阶段结束后遗留下来的少量 SATB 记录
    - 筛选回收 : 根据用户期待的 GC 停顿时间制定回收计划
  - 回收模式
    - Minor GC/Young GC
      - 回收所有 Eden、Survivor 区
      - 复制一些存活对象到 Old 区、Survivor 区
    - Mixed GC
- CMS 与 G1 的区别
  - G1 分区域 每个区域是有老年代概念的，但是收集器以整个区域为单位收集
  - G1 回收后马上合并空闲内存，而 CMS 会在 STW 的时候合并

## Full GC

- 老年代空间不足
- `system.gc()` 通知 JVM 进行 Full GC
- 持久代空间不足

## STW

- stop the word 在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起, 是 Java 中一种全局暂停现象，全局停顿，所有 Java 代码停止，Native 代码可以执行，但不能与 JVM 交互

## 性能调优

- 设置堆的最大最小值 -xms -xmx
- 调整老年和年轻代的比例
  - -XX:newSize设置绝对大小
  - 防止年轻代堆收缩：老年代同理
- 主要看是否存在更多持久对象和临时对象
- 观察一段时间 看峰值老年代如何 不影响gc就加大年轻代
- 配置好的机器可以用 并发收集算法
- 每个线程默认会开启 1M 的堆栈 存放栈帧 调用参数 局部变量 太大了 500k 够了
- 原则 就是减少 GC STW

## FullGC 内存泄露排查

- jasvism
- dump
- 监控配置 自动 dump

## 逃逸分析

- 概念
  - Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术
  - 开启逃逸分析：-XX:+DoEscapeAnalysis
  - 关闭逃逸分析：-XX:-DoEscapeAnalysis
  - 显示分析结果：-XX:+PrintEscapeAnalysis
- 逃逸状态
  - 全局逃逸
    - 即一个对象的作用范围逃出了当前方法或者当前线程
    - 场景
      - 对象是一个静态变量
      - 对象是一个已经发生逃逸的对象
      - 对象作为当前方法的返回值
  - 参数级逃逸
    - 即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸
  - 没有逃逸
    - 即方法中的对象没有发生逃逸
- 逃逸分析优化
  - 锁消除
    - 开启锁消除：-XX:+EliminateLocks
    - 关闭锁消除：-XX:-EliminateLocks
  - 标量替换
    - 开启标量替换：-XX:+EliminateAllocations
    - 关闭标量替换：-XX:-EliminateAllocations
    - 显示标量替换详情：-XX:+PrintEliminateAllocations
  - 栈上分配
    - 当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能
- 结论
  - 在平时开发过程中尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间

## JVM 调优

- OOM
  - Java heap space
    - 当堆内存（Heap Space）没有足够空间存放新创建的对象时，会抛出
    - 场景
      - 请求创建一个超大对象，通常是一个大数组
      - 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值
      - 过度使用终结器（Finalizer），该对象没有立即被 GC
      - 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收
    - 解决方案
      - 针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可
      - 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制
      - 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级
      - 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接
  - GC overhead limit exceeded
    - 当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出
    - 场景与解决方案与Java heap space类似
  - Permgen space
    - 该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大
    - 解决方案
      - 程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间
      - 应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决
      - 运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class
      - 如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap-dump:format=b,file=dump.hprof<process-id> ，然后利用 Eclipse MAT功能逐一分析开销最大的 classloader 和重复 class
  - Metaspace（元空间）
    - 该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大
    - 场景与解决方案与Permgen space类似，需注意调整元空间大小参数为 -XX:MaxMetaspaceSize
  - Unable to create new native thread
    - 当 JVM 向底层操作系统请求创建一个新的 Native 线程时，如果没有足够的资源分配就会报此类错误
    - 场景
      - 线程数超过操作系统最大线程数 ulimit 限制
      - 线程数超过 kernel.pid_max（只能重启）
      - Native 内存不足
    - 解决方案
      - 升级配置，为机器提供更多的内存
      - 降低 Java Heap Space 大小
      - 修复应用程序的线程泄漏问题
      - 限制线程池大小
      - 使用 -Xss 参数减少线程栈的大小
      - 调高 OS 层面的线程最大数：执行 ulimia-a 查看最大线程数限制，使用 ulimit-u xxx 调整最大线程数限制
  - Out of swap space？
    - 虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 Outof swap space? 错误
    - 场景
      - 地址空间不足
      - 物理内存已耗光
      - 应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放
      - 执行 jmap-histo:live<pid> 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题
    - 解决方案
      - 升级地址空间为 64 bit
      - 使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法
      - Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值
      - 升级服务器配置/隔离部署，避免争用
  - Kill process or sacrifice child
    - 有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，Killprocessorsacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的
    - 场景
      - 默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。
        然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源
    - 解决方案
      - 升级服务器配置/隔离部署，避免争用
      - OOM Killer 调优
  - Requested array size exceeds VM limit
    - JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制
    - 解决方案
      - 检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行
  - Direct buffer memory
    - Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误
    - 解决方案
      - Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查
      - 检查是否直接或间接使用了 NIO，如 netty，jetty 等
      - 通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值
      - 检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc（）失效
      - 检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间
      - 内存容量确实不足，升级配置
- 内存泄露
- 线程死锁
- 锁争用
- Java进程消耗CPU过高







